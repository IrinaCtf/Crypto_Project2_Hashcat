import hashlib as hl

class Detective:
        
    def __init__(self, limit:int, hashFunc):
        """
        limit: determines the number upto which primes are generated
        hashFunc: a hard predicate that takes encoded strings as input and throws a hex hash digest out
        """
        try:
            assert(limit > 0) # positive limit
        except:
            print(f"ERR: limit {limit} is non-positive!")
            exit(1)
        
        try:
            assert(hashFunc("hashable") != None) # checks if function computes
        except:
            print(f"ERR: hash function compuation failure!")
            exit(1)

        self.__lvl = self._gen_primes(limit)
        self.__hash = hashFunc

        pass

    def _gen_primes(self, limit:int) -> int:
        """
        INPUT: limit, int
        OUTPUTL pi(x); number of primes, int
        upto the limit, collects all primes. Returns number of primes, pi(x)
        Uses Sieve of Eratosthenes
        """
        if limit < 2:
            self.__primes = []
            return 0
        
        primes = [ 2 ]

        for number in range(3, limit + 1):
            isPrime = True
            for prime in primes:
                if number % prime == 0:
                    isPrime = False
            
            if isPrime:
                primes.append(number)
        
        self.__primes = primes

        return len(primes)

    def superSet(self, message:str) -> tuple:
        """
        INPUT: message, str [not encoded]
        OUTPUT: superset; set of hashsets divided by primes generated by level, tuple

        Generates a set of sets, containing hashes of segments broken apart by primes generated from level
        RETURNS [] if failed
        """
        segmentSet = []

        for segmentCount in range(0, self.__lvl):
            if segmentCount > len(message):
                return segmentSet

            segments = []
            width = len(message) // self.__primes[segmentCount]
            
            for idx in range(0, self.__primes[segmentCount]):
                segmentHash = self.__hash(message[idx : idx + width])
                segments.append(segmentHash)
            
            segmentSet.append(segments)
        
        return segmentSet
    
    def remember(self, message:str) -> tuple:
        """
        INPUT: message, type str
        OUTPUT: segment superset, tuple (set of hash sets)
        
        Creates a segment superset and stores it internally.
        Pair this with the inspect method to detect corruptions

        RETURNS [] if failed
        """
        self.__segmentset = self.superSet(message)
        return self.__segmentset
    
    def inspect(self, suspect:str) -> tuple:
        """
        INPUT: suspect, type str
        OUTPUT: returns a superset of identical dimentionality, True where uncorrupted, and False whereever it occurs

        Compares stored hash superset with the superset of said suspect.
        RETURNS sets of Trues if no corruption detected.
        """
        set_index = 0

        checkSuperset = []

        for segmentCount in range(0, self.__lvl):
            if segmentCount > len(suspect):
                return checkSuperset
                
            width = len(suspect) // self.__primes[segmentCount]
            
            segment_index = 0

            checkSet = []

            for idx in range(0, self.__primes[segmentCount]):
                segmentHash = self.__hash(suspect[idx : idx + width])

                checkSet.append(segmentHash == self.__segmentset[set_index][segment_index])
                
                # if segmentHash != self.__segmentset[set_index][segment_index]:
                #     return (set_index, segment_index)
                
                segment_index += 1
            
            checkSuperset.append(checkSet)
            
            set_index += 1
        
        return checkSuperset
        # return (-1, -1)
        


message = "this is a secret"
corrupted = "this is b secret"
gadget = Detective(2 * len(message), lambda x: hl.md5(x.encode('ascii')).hexdigest())

print(gadget.remember(message))

print(gadget.inspect(corrupted))