import math as mt
import hashlib as hl
import random as rnd
from string import ascii_letters as ascii_set


class Detective:
    """
    Detective implements the tagging mechanism for corruption detection.
    This method involves breaking data into prime number segments
    """
        
    def __init__(self, limit:int, hashFunc, order:int=2):
        """
        limit: determines the number upto which primes are generated
        hashFunc: a hard predicate that takes encoded strings as input and throws a hex hash digest out
        """
        try:
            assert(limit > 0) # positive limit
        except:
            print(f"ERR: limit {limit} is non-positive!")
            exit(1)
        
        try:
            assert(hashFunc("hashable") != None) # checks if function computes
        except:
            print(f"ERR: hash function compuation failure!")
            exit(1)

        try:
            assert(order >= 1) # checks if function computes
        except:
            print(f"ERR: order {order} is not computable! order must be at least 2")
            exit(1)

    
        self.__lvl = self._gen_primes(limit, order)
        self.__hash = hashFunc

        pass

    def _gen_primes(self, limit:int, order:int) -> int:
        """
        INPUT: limit, int
        OUTPUTL pi(x); number of primes, int
        upto the limit, collects all primes. Returns number of primes, pi(x)
        Uses Sieve of Eratosthenes
        """
        if limit < 2:
            self.__primes = []
            return 0
        
        primes = [ 2 ]

        for number in range(3, int(mt.pow(limit, 1/order)) + 1):
            isPrime = True
            for prime in primes:
                if number % prime == 0:
                    isPrime = False
            
            if isPrime:
                primes.append(number)
        
        self.__primes = primes

        return len(primes)
    
    def primes(self) -> tuple:
        return self.__primes

    def superSet(self, message:str) -> tuple:
        """
        INPUT: message, str [not encoded]
        OUTPUT: superset; set of hashsets divided by primes generated by level, tuple

        Generates a set of sets, containing hashes of segments broken apart by primes generated from level
        RETURNS [] if failed
        """
        segmentSet = []

        for segmentCount in range(0, self.__lvl):
            if segmentCount > len(message):
                return segmentSet

            segments = []
            width = len(message) // self.__primes[segmentCount]
            
            for idx in range(0, len(message), width):
                segmentHash = self.__hash(message[idx : idx + width])
                segments.append(segmentHash)
            
            segmentSet.append(segments)
        
        return segmentSet
    
    def remember(self, message:str) -> tuple:
        """
        INPUT: message, type str
        OUTPUT: segment superset, tuple (set of hash sets)
        
        Creates a segment superset and stores it internally.
        Pair this with the inspect method to detect corruptions

        RETURNS [] if failed
        """
        self.__segmentset = self.superSet(message)
        return self.__segmentset
    
    def inspect(self, suspect:str) -> tuple:
        """
        INPUT: suspect, type str
        OUTPUT: returns a superset of identical dimentionality, True where uncorrupted, and False whereever it occurs

        Compares stored hash superset with the superset of said suspect.
        RETURNS sets of Trues if no corruption detected.
        """
        try:
            assert(len(suspect) == len(self.__segmentset)) #modification
        except AssertionError:
            print(f"disimilar length in inspect(): expected {len(self.__segmentset)}, got {len(suspect)}")
        set_index = 0

        checkSuperset = []

        for segmentCount in range(0, self.__lvl):
            if segmentCount > len(suspect):
                return checkSuperset
                
            width = len(suspect) // self.__primes[segmentCount]
            
            segment_index = 0

            checkSet = []

            for idx in range(0, len(suspect), width):
                segmentHash = self.__hash(suspect[idx : idx + width])

                checkSet.append(segmentHash == self.__segmentset[set_index][segment_index])
                
                # if segmentHash != self.__segmentset[set_index][segment_index]:
                #     return (set_index, segment_index)
                
                segment_index += 1
            
            checkSuperset.append(checkSet)
            
            set_index += 1
        
        return checkSuperset
        # return (-1, -1)
        
def randCorruptSeq(message:str, length:int) -> { str, tuple }:
    """
    INPUT: message; string to be corrupted, str
           length; length of corruption sequence, int

    OUTPUT: corrupted string, str
            corruption index range (pair), tuple
    
    Corrupts a given string given fixed corruption length sequentially.
    Returns the corrupted string and the location (in indicies) of said corruption [start index, end index]
    """
    if length > len(message):
        return message, (-1, -1)

    start = rnd.randint(0, len(message) - length)

    previous = message[:start]
    next = message[start + length:]
    corruption = ''.join(rnd.choice(ascii_set) for _ in range(length))

    return previous + corruption + next, (start, start + length - 1)

message =   "I have a lot of characters fitting in here, can you find the error?"
corrupted, target = randCorruptSeq(message, 8)

print(f'Error at {target}')

gadget = Detective(len(message), lambda x: hl.md5(x.encode('ascii')).hexdigest())
# gadget = Detective(len(message), lambda x: x)

print(gadget.remember(message))
print(gadget.superSet(corrupted))

print(gadget.inspect(corrupted))